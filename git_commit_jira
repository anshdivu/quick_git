#!/usr/bin/env ruby
require 'optparse'

class Git
  def branch
    @branch ||= Branch.new
  end

  def branch_name
    branch.name
  end

  def commit!(msg, options = {})
    if options[:stage_all]
      system "git commit -v -a -m \"#{msg}\""
    else
      system "git commit -v -m \"#{msg}\""
    end
  end

  def last_commit_id
    @last_commit_id ||= `git rev-parse HEAD`.chomp
  end

  def last_commit_url
    "#{remote_url}/commit/#{last_commit_id}"
  end

  def push!
    system "git push origin #{branch_name}"
  end

  def remote_url
    @remote_url ||= create_remote_url
  end

  def jira_number
    branch.jira_number || raise('Incorrect Branch Name Format (Branch Name Format => "PREFIX-NUMBER-jira-description")')
  end

  def jira_prefix
    branch.jira_prefix || github_org_name || raise('jira prefix not found from remote repo')
  end

  private

  def create_remote_url
    raw_remote_url = `git ls-remote --get-url`

    if raw_remote_url.start_with?('git@') # if the remote url is ssh protocol instead of https
      _, base_url, org_slash_repo = raw_remote_url.split(%r{@(.*):})
      raw_remote_url = "http://#{base_url}/#{org_slash_repo}"
    end

    raw_remote_url.chomp(".git\n")
  end

  def github_org_name
    org_name = remote_url.split('/')[-2]
    org_name && org_name.upcase
  end
end

class Branch
  def name
    @name ||= `git symbolic-ref --short HEAD`.chomp
  end

  def jira_prefix
    @jira_prefix ||= jira[:prefix]
  end

  def jira_number
    @jira_number ||= jira[:num]
  end

  private

  def jira
    prefix_or_jira_num, jira_num, _ = name.split('-', 3)

    if number?(prefix_or_jira_num) # assuming branch name format => NUM-my-description
      {
        prefix: nil,
        num: prefix_or_jira_num
      }
    elsif number?(jira_num) # assuming branch name format => PREFIX-NUM-my-description
      {
        prefix: prefix_or_jira_num,
        num: jira_num
      }
    else # invalid branch naming format
      {
        prefix: nil,
        num: nil
      }
    end
  end

  def number?(num)
    !!Float(num) rescue false
  end
end

class CommandLine
  attr_reader :options, :git
  def initialize
    @options = cmd_options
    @git = Git.new
  end

  def run
    git.commit!(message, stage_all: options[:stage_all]) if options[:msg]

    if options[:push]
      git.push!
      puts git.last_commit_url
    end

    copy_and_open!(git.last_commit_url) if options[:open]
  end

  def copy_and_open!(url)
    return false if url.empty?

    system "echo '#{url}' | pbcopy"
    system "open #{url}"
  end

  def message
    prefix = options.fetch(:prefix) { git.jira_prefix }
    number = options.fetch(:number) { git.jira_number }

    "#{prefix}-#{number} #{options[:msg]}"
  end

  def cmd_options
    options = {}
    opt_parser = OptionParser.new do |opts|
      opts.banner = 'Usage: gcj -m "commit message"'

      opts.on('-a', '--all', 'automatically stage files that have been modified and/or deleted') do
        options[:stage_all] = true
      end

      opts.on('-h','--help','Prints help message') do
        puts opt_parser.help
      end

      opts.on('-m', '--message=<msg>', "Uses the given <msg> as the commit message. Uses '<prefix>-<number> <msg>' as the commit message format") do |message|
        options[:msg] = message
      end

      opts.on('-n', '--number=<number>', "Uses the given <number> as part of the commit message. The commit message format will be '<prefix>-<number> <msg>'") do |number|
        options[:number] = jira_num
      end

      opts.on('-o', '--open', 'Opens commit url in browser and copies the url to clipboard') do
        options[:open] = true
      end

      opts.on('-p', '--push', 'Push commits to remote') do
        options[:push] = true
      end

      opts.on('-r', '--prefix=<prefix>', "Uses the given <prefix> as part of the commit message. The commit message format will be '<prefix>-<NUMBER> <msg>'") do |prefix|
        options[:prefix] = prefix
      end
    end
    opt_parser.parse!

    options[:msg] = ARGV[0] if !options.has_key?(:msg) && ARGV.size == 1

    options
  end
end

if __FILE__ == $PROGRAM_NAME
  CommandLine.new.run
end
