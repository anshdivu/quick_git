#!/usr/bin/env ruby
require 'optparse'

class Git
  def branch
    @branch ||= Branch.new
  end

  def branch_name
    branch.name
  end

  def add_all!
    system 'git add -A .'
  end

  def commit!(msg)
    system "git commit -v -m \"#{msg}\""
  end

  def push!
    status = system("git push origin #{branch_name}")
    puts last_commit_url if status
    status
  end

  def last_commit_id
    @last_commit_id ||= `git rev-parse HEAD`.chomp
  end

  def last_commit_url
    "#{remote_url}/commit/#{last_commit_id}"
  end

  def remote_url
    @remote_url ||= create_remote_url
  end

  def jira_number
    branch.jira_number || raise('Incorrect Branch Name Format (Branch Name Format => "PREFIX-NUMBER-jira-description")')
  end

  def jira_prefix
    branch.jira_prefix || github_org_name || raise('jira prefix not found from remote repo')
  end

  private

  def create_remote_url
    raw_remote_url = `git ls-remote --get-url`.chomp
    convert_ssh_url_to_http_url(raw_remote_url)
  end

  def convert_ssh_url_to_http_url(raw_remote_url)
    return raw_remote_url unless raw_remote_url.start_with?('git@')

    _, base_url, org_slash_repo = raw_remote_url.split(/@(.*):/)
    "http://#{base_url}/#{org_slash_repo}".chomp('.git')
  end

  def github_org_name
    org_name = remote_url.split('/')[-2]
    org_name && org_name.upcase
  end
end

class Branch
  def name
    @name ||= `git symbolic-ref --short HEAD`.chomp
  end

  def jira_prefix
    @jira_prefix ||= jira[:prefix]
  end

  def jira_number
    @jira_number ||= jira[:num]
  end

  private

  def jira
    prefix_or_jira_num, jira_num, _ = name.split('-', 3)

    if number?(prefix_or_jira_num) # assuming branch name format => NUM-my-description
      {
        prefix: nil,
        num: prefix_or_jira_num
      }
    elsif number?(jira_num) # assuming branch name format => PREFIX-NUM-my-description
      {
        prefix: prefix_or_jira_num,
        num: jira_num
      }
    else # invalid branch naming format
      {
        prefix: nil,
        num: nil
      }
    end
  end

  def number?(num)
    !!Float(num) rescue false
  end
end

class CommandLine
  attr_reader :options, :git
  def initialize
    @options = cmd_options
    @git = Git.new
  end

  def run
    git.add_all! if options[:add_all]
    git.commit!(message) if options[:msg]
    git.push! if options[:push]
    copy_and_open!(git.last_commit_url) if options[:open]
  end

  def copy_and_open!(url)
    system "echo '#{url}' | pbcopy"
    system "open #{url}"
  end

  def message
    prefix = options.fetch(:prefix) { git.jira_prefix }
    number = options.fetch(:number) { git.jira_number }

    "#{prefix}-#{number}: #{options[:msg]}"
  end

  def cmd_options
    options = {}
    opt_parser = OptionParser.new do |opts|
      opts.banner = 'Usage: gcj -m "commit message"'

      opts.on('-a', '--all', 'automatically stage files that have been modified, added or deleted') do
        options[:add_all] = true
      end

      opts.on('-h','--help','Prints help message') do
        puts opt_parser.help
      end

      opts.on('-m', '--message=<msg>', "Uses the given <msg> as the commit message. Uses '<prefix>-<number> <msg>' as the commit message format") do |message|
        options[:msg] = message
      end

      opts.on('-n', '--number=<number>', "Uses the given <number> as part of the commit message. The commit message format will be '<prefix>-<number> <msg>'") do |number|
        options[:number] = jira_num
      end

      opts.on('-o', '--open', 'Opens commit url in browser and copies the url to clipboard') do
        options[:open] = true
      end

      opts.on('-p', '--push', 'Push commits to remote') do
        options[:push] = true
      end

      opts.on('-r', '--prefix=<prefix>', "Uses the given <prefix> as part of the commit message. The commit message format will be '<prefix>-<NUMBER> <msg>'") do |prefix|
        options[:prefix] = prefix
      end
    end
    opt_parser.parse!

    options[:msg] = ARGV[0] if !options.has_key?(:msg) && ARGV.size == 1

    options
  end
end

if __FILE__ == $PROGRAM_NAME
  CommandLine.new.run
end
